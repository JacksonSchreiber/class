####################NETWORK FUNDAMENTALS####################################
    OSI Model

        Data Link Sub Layers
            MAC (Media Access Control)
            LLC (Logical Link Control)
            #Ethertype:
                0800 IPv4
                0806 ARP
                86DD IPv6
                8100 VLAN Tag
        Transport
            TCP Flags: CWR ECE URG ACK PSH RST SYN FIN
            FTP ACTIVE vs Passive. Active can trigger firewall

    TCPDUMP
        sudo tcpdump -r ids.pcap -vX #for hex dump. -vXX to show ethernet header
            filter with grep
            sudo tcpdump -r ids.pcap not tcp port 23 -c 10 #show first 10 packets that arent port 23
        sudo tcpdump -w write.pcap #make a pcap

    
    BERKELEY PACKET FILTERS #first byte is always 0
        tcpdump header[startByte:Offset]
        OFFSETS: 1, 2, 4

        EX look for Ethertype (byte 13)
            tcpdump ether[12:2] #12th byte to 14th (including 0)
        EX look for TTL (9th byte)
            tcpdump ip[8] #just one byte doesn't need :

        sudo tcpdump "ether[12:2] = 0x0800" -d #bytecode
            #check how kernel navigates through headers
        
        BITWISE MASKING
            EX look  for just ip version (4 bits of 0th byte)
                tcpdump ip[0]&0xF0=0x40
                            get all where first 4 bits of 0th byte = 4 (ipv4)
            EX TCP flag syn
                tcpdump tcp[13]&0x3F = 0x02 #exclude the CWR, ECE, look for syn
            EX TCP christmas scan #URG, PSH, FIN
                tcpdump tcp[13]&0x3F = 0x29 #look for URG, PSH, FIN bits set
    CONVERT DSCP to Decimal value       DSCP * 4.
        DSCP 24 = 96

    LAYER 2 SWITCHING TECHS
        CAM Table - MAC address table
        BPDUs used in STP. contains info on ports, addresses, priorities..
            messages to determine whether to turn off port
        Discovery Protocol (LLDP, CDP, FDP)

#############PACKET CREATION AND SOCKET PROGRAMMING###########################

    Socket Types
        Stream Sockets      - Connection oriented and sequenced. TCP, SCTP, Bletooth
        Datagram Sockets    - Connectionless. UDP
        Raw Sockets         - Direct sending, receiving of IP packets w/out automatic protocol-specific fwd
            nmap, tcpdump, scapy

            User Space Sockets      - do not requre elevated privileges
                tcpdump/wireshark to read file
                nmap with no switches
                netcat to connect to listener
                netcat to create listener above 1024
                using /dev/tcp or /dev/udp to transmit
            Kernel Spcae Sockets    - access HW directly, create packets from scratch
                tcp/wireshark to capture
                nmap for OS ID or specific flags
                netcat to create listener in well known port range
                scapy/python to craft 
                network devices w/ routing protocols like OSPF

   Python3 Network Programming 
        Python3 Socket Library and socket.socket function

        import socket
            s = socket.socket(FAMILY, socket.TYPE, socket.PROTOCOL)

        SOCKET.SOCKET FUNCTION #3 arguments
            socket.socket([*family*[,*type*[*proto*]]])

        #STREAM SOCKET EX# echo message | nc -lp 54321
            import socket
            #This works with s = socket.socket() due to AF_INET and SOCK_STREAM being defaults
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

            ipaddr = '127.0.0.1'
            port = 54321

            s.connect((ipaddr, port))

            #b sends string as bytes-like object
            s.send(b'Hello\n')

            #Recommended that buffersize used with recvfrom is power of 2 and not large # of bits
            response, conn = s.recvfrom(1024)

            #to receive msg sent as a bytes-like-obj must decode into utf-8 (default)
            print(response.decode())
            
            s.close()
        
        #DATAGRAM SOCKET EX# echo message | nc -lp 54321 -u
            import socket

            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

            ipaddr = '127.0.0.1'
            port = 54321


            s.connect((ipaddr, port))

            s.send(b'Hello\n')

            response, conn = s.recvfrom(1024)

            print(response.decode())

            #don't need to close, its datagram

    RAW IPv4 SOCKETS
        #For building socket
        import socket

        #System level commands
        import sys


        #Establish packet structure, allows direct access to functions in struct module
        from struct import *

        #Create raw socket
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)

        except socket.error as msg:
            print(msg)
            sys.exit()

        packet = ''

        src_ip = "99.99.99.99"
        dst_ip = "10.3.0.2"

        #Add IPv4 header info
        ip_ver_ihl = 69    #decimal conversion of 0x45 for version, internet header len
        ip_tos = 0          #Combines DSCP and ECN fields
        ip_len = 0          #Kernel will fill in actual length
        ip_id = 12345       #sets ip ID for the packet
        ip_frag = 0         #sets fragmentation to off
        ip_ttl = 64         #determines the TTL when leaving machine
        ip_proto = 16       #sets IP protocol to 16 (Chaos) If it was 6 (TCP) or 17 (UDP), additional headers would be required
        ip_check = 0        #Kernel will fill in checksum for packet
        ip_srcadd = socket.inet_aton(src_ip)
        ip_dstadd = socket.inet_aton(dst_ip)    #inet_aton(string) converts IP to a 32 bit binary numbers

        ip_header = pack('!BBHHHBBH4s4s' ,ip_ver_ihl, ip_tos, ip_len, ip_id, ip_frag, ip_ttl, ip_proto, ip_check, ip_srcadd, ip_dstadd)

        
        message = b'mmmmmmessage'
        packet = ip_header + message

        #Send packet
        s.sendto(packet, (dst_ip, 0))

NETWORK RECONNAISSANCE - active, passive, internal, external
    Passive Recon
        #IPs, Sub-Domains, 3rd party sites, people and techs, vulnerabilities
        #WHOIS queries, job site listings, phone nums, passive OS fingerprinting

        whois
        dig - mail servers, dns servers, SOA, TXT, zone transfers
            dig SOA
            dig MX
            dig TXT     #could be encoded in base64
            
            dig axfr @nsztm1.digi.ninja zonetransfer.me #ZONE TRANSFER
                #   @SOA domain.com
        netcraft.com - bunch of info on domains
        wayback/archive.com - website archives
        *ccboe.net -site:*.ccboe.net    #(in google search) domain association
        
        site:*.ccboe.net "Powered by"   #search for technologies used by ccboe (google search)


        shodan - website that crawls web to look for unsecure devices

    Network Scanning - Remote to Local, Local to Remote, Local to Local, Remote to Remote
        nmap -sT 192.168.65.1-30 -p 21,22,23,80 
        nmap -sV <ip> <ports>
        nmap -O #os
        nmap -sP <ip range> #ping sweep
            for i in {1..254} ;do (ping -c 1 192.168.1.$i | grep "bytes from" &) ;done
        nmap -sU <ip range> #udp scan
           # Full Connect scan (NMAP) is only scan that will work through tunnel
        idle scan - using proxy to scan for you
        
    Commands
        curl 10.0.0.104 #cats the webpage html. can read txt file
            curl 10.0.0.104/file.txt
            curl ftp://10.0.0.104 #use port 21
        wget -r <ip> #download all files on website. auto put in directory
            firefox <file>      - view picture files

        netstat -antp
        ss -antp
        sudo arp -a
        
        #scan with netcat
        sudo nc -nvzw1 192.168.20.65 21 22 23 80 #z - port scanner, v - verbose, w - wait, n - no dns; only IP
            or range with 1-25
        
        nc BANNER GRAB
            nc 10.0.0.104 21 #connect to ftp server, possible get banner
            nc 10.0.0.104 80
                GET / #get at beginning of directory
            nc -u <ip> <port> #connect to udp service
        
        find / -iname "hint*" 2>/dev/null
        find / -iname "*pcap" 2>/dev/null

DATA TRANSFER, MOVEMENT, AND REDIRECTION
    TFTP (no directory structure, no authentication, no encryption)
    FTP (Control TCP/21, Data TCP/20, Authentication with clear-text sign in)
        wget -r ftp://<ip>
    SFTP (Adds FTP to SSH)
    FTPS (TCP/443, adds SSL/TLS)


    ACTIVE FTP - client initiate connection on port 21, data initiated from server on port 20. Doesn't work over a tunnel
    PASSIVE FTP - client initiate connection on port 21, data initiated from client. Works over tunnel
        curl ftp://<ip>

    
    SCP (DATA CHANNEL ENCRYPTED WITH SYMMETRIC, CONTROL/AUTHENTICATION WITH ASYMMETRIC)
        HOST KEY - uses asymmetric encryption for authentication. located on server
        
    NETCAT - read, write data across ntw #cat throws up (deleivers)
        Client (sends file): nc 10.2.0.2 9001 < file.txt #either client or listener can send info once connected
        Listener (receive file): nc -l -p 9001 > newfile.txt
        
        #ALL POSSIBLE PIVOT COMBOS
        Listener  --> Client    | Client    --> Listener
        Client    --> Listener  | Listener  --> Client       
        Listener  --> Client    | Listener  --> Client
        Client    --> Listener  | Client    --> Listener

        NAMED PIPE (and nc example w/ pivot) #acts as buffer
            #LISTENER2 (SENDS INFO) RUN LISTENERS BEFORE RELAY
            nc -l -p 9002 < infile.txt
            #LISTENER1 (RECEIVE INFO)
            nc -l -p 9001 > outfile.txt

           #RELAY CLIENT
            mkfifo mypipe #bidirectional, persistent
            nc 10.1.0.2 9002 0< mypipe | nc 10.2.0.2 9001 1> mypipe
                #send info to mypipe    #take info from mypipe, send to nc
            
        REVERSE SHELL (slide 7.7)
            nc -l -p <port> -e /bin/bash
    /DEV/TCP
        #receiving box
        nc -l -p 1111 > file.txt
        #sending box
        cat file > /dev/tcp/10.2.0.2/1111
    
    SSH PORT FORWARDING
        
        LOCAL

            INET        SALLY       JACK
                       #1.1.1.1    #2.2.2.2
            #DIRECT CONNECT TO PORT THAT IS SERVICE (HTTP, TELNET,..)
            from INET:  ssh sally@1.1.1.1 -L 1234:2.2.2.2:80

            from INET:  curl localhost:1234
                #different terminal

        DYNAMIC
            ps -elf | grep "9050"       #look for background proxychains
            
            ssh sally@2.2.2.2 -D 9050 #always 9050
            proxychains ./scan.sh

    REMOTE PORT FORWARDING  - only to get through firewall. you connect to me and ill forward to target (insider)
        from inside

    net2
    ATROPIA (T3) 10.50.27.79 net2_student11
    Pineland T4 10.50.30.62 net2_student11
    T5 10.50.20.155




