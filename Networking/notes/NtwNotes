####################NETWORK FUNDAMENTALS####################################
    OSI Model

        Data Link Sub Layers
            MAC (Media Access Control)
            LLC (Logical Link Control)
            #Ethertype:
                0800 IPv4
                0806 ARP
                86DD IPv6
                8100 VLAN Tag
        Transport
            TCP Flags: CWR ECE URG ACK PSH RST SYN FIN
            FTP ACTIVE vs Passive. Active can trigger firewall

    TCPDUMP
        sudo tcpdump -r ids.pcap -vX #for hex dump. -vXX to show ethernet header
            filter with grep
            sudo tcpdump -r ids.pcap not tcp port 23 -c 10 #show first 10 packets that arent port 23
        sudo tcpdump -w write.pcap #make a pcap

    
    BERKELEY PACKET FILTERS #first byte is always 0
        tcpdump header[startByte:Offset]
        OFFSETS: 1, 2, 4

        EX look for Ethertype (byte 13)
            tcpdump ether[12:2] #12th byte to 14th (including 0)
        EX look for TTL (9th byte)
            tcpdump ip[8] #just one byte doesn't need :

        sudo tcpdump "ether[12:2] = 0x0800" -d #bytecode
            #check how kernel navigates through headers
        
        BITWISE MASKING
            EX look  for just ip version (4 bits of 0th byte)
                tcpdump ip[0]&0xF0=0x40
                            get all where first 4 bits of 0th byte = 4 (ipv4)
            EX TCP flag syn
                tcpdump tcp[13]&0x3F = 0x02 #exclude the CWR, ECE, look for syn
            EX TCP christmas scan #URG, PSH, FIN
                tcpdump tcp[13]&0x3F = 0x29 #look for URG, PSH, FIN bits set
    CONVERT DSCP to Decimal value       DSCP * 4.
        DSCP 24 = 96

    LAYER 2 SWITCHING TECHS
        CAM Table - MAC address table
        BPDUs used in STP. contains info on ports, addresses, priorities..
            messages to determine whether to turn off port
        Discovery Protocol (LLDP, CDP, FDP)

#############PACKET CREATION AND SOCKET PROGRAMMING###########################

    Socket Types
        Stream Sockets      - Connection oriented and sequenced. TCP, SCTP, Bletooth
        Datagram Sockets    - Connectionless. UDP
        Raw Sockets         - Direct sending, receiving of IP packets w/out automatic protocol-specific fwd
            nmap, tcpdump, scapy

            User Space Sockets      - do not requre elevated privileges
                tcpdump/wireshark to read file
                nmap with no switches
                netcat to connect to listener
                netcat to create listener above 1024
                using /dev/tcp or /dev/udp to transmit
            Kernel Spcae Sockets    - access HW directly, create packets from scratch
                tcp/wireshark to capture
                nmap for OS ID or specific flags
                netcat to create listener in well known port range
                scapy/python to craft 
                network devices w/ routing protocols like OSPF

   Python3 Network Programming 
        Python3 Socket Library and socket.socket function

        import socket
            s = socket.socket(FAMILY, socket.TYPE, socket.PROTOCOL)

        SOCKET.SOCKET FUNCTION #3 arguments
            socket.socket([*family*[,*type*[*proto*]]])

        #STREAM SOCKET EX# echo message | nc -lp 54321
            import socket
            #This works with s = socket.socket() due to AF_INET and SOCK_STREAM being defaults
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

            ipaddr = '127.0.0.1'
            port = 54321

            s.connect((ipaddr, port))

            #b sends string as bytes-like object
            s.send(b'Hello\n')

            #Recommended that buffersize used with recvfrom is power of 2 and not large # of bits
            response, conn = s.recvfrom(1024)

            #to receive msg sent as a bytes-like-obj must decode into utf-8 (default)
            print(response.decode())
            
            s.close()
        
        #DATAGRAM SOCKET EX# echo message | nc -lp 54321 -u
            import socket

            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

            ipaddr = '127.0.0.1'
            port = 54321


            s.connect((ipaddr, port))

            s.send(b'Hello\n')

            response, conn = s.recvfrom(1024)

            print(response.decode())

            #don't need to close, its datagram

    RAW IPv4 SOCKETS
        #For building socket
        import socket

        #System level commands
        import sys


        #Establish packet structure, allows direct access to functions in struct module
        from struct import *

        #Create raw socket
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)

        except socket.error as msg:
            print(msg)
            sys.exit()

        packet = ''

        src_ip = "99.99.99.99"
        dst_ip = "10.3.0.2"

        #Add IPv4 header info
        ip_ver_ihl = 69    #decimal conversion of 0x45 for version, internet header len
        ip_tos = 0          #Combines DSCP and ECN fields
        ip_len = 0          #Kernel will fill in actual length
        ip_id = 12345       #sets ip ID for the packet
        ip_frag = 0         #sets fragmentation to off
        ip_ttl = 64         #determines the TTL when leaving machine
        ip_proto = 16       #sets IP protocol to 16 (Chaos) If it was 6 (TCP) or 17 (UDP), additional headers would be required
        ip_check = 0        #Kernel will fill in checksum for packet
        ip_srcadd = socket.inet_aton(src_ip)
        ip_dstadd = socket.inet_aton(dst_ip)    #inet_aton(string) converts IP to a 32 bit binary numbers

        ip_header = pack('!BBHHHBBH4s4s' ,ip_ver_ihl, ip_tos, ip_len, ip_id, ip_frag, ip_ttl, ip_proto, ip_check, ip_srcadd, ip_dstadd)

        
        message = b'mmmmmmessage'
        packet = ip_header + message

        #Send packet
        s.sendto(packet, (dst_ip, 0))
























